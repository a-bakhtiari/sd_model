# User Instructions for Theory Planning (Step 1)
# Your instructions below:

## Core Theoretical Requirements
The model must capture both:
1. **Apprenticeship dynamics**: How newcomers learn from experts through mentoring, coaching, scaffolding, and guided participation. Entry-level developers progress to expertise through these apprenticeship relationships.
2. **Community of practice dynamics**: How developers move from legitimate peripheral participation to full community membership and core participation.

These two theoretical lenses (Cognitive Apprenticeship and Communities of Practice) are central to understanding how entry-level developers progress to expertise.

## Specific Design Requirements

### Main Pipeline Structure (MANDATORY)

Create EXACTLY 4 processes corresponding to the career progression pipeline:

1. **Process 1**: Prospects → Entry-level/Newcomer
2. **Process 2**: Entry-level/Newcomer → Apprentice/Peripheral Participant
3. **Process 3**: Apprentice/Peripheral Participant → Practicing Contributor
4. **Process 4**: Practicing Contributor → Expert/Core Developer

DO NOT create additional processes. Cross-cutting concerns (governance, codebase quality, review processes) should be woven into these 4 main processes.

### Project-Specific Requirements

For this OSS developer progression model, ensure narratives explicitly mention these mechanisms:

**Skill Development Mechanisms:**
- Learning processes: absorptive capacity, practice accumulation, feedback cycles
- Mentoring: availability, quality, scaffolding patterns
- Knowledge: documentation quality, examples, architectural understanding

**Community Participation Mechanisms:**
- Social integration: trust building, reputation accrual, recognition events
- Belonging: identity formation, psychological safety, legitimacy signals
- Relationships: mentor ties, peer connections, expert accessibility

**Governance and Codebase Dynamics:**
- Governance: review approval requirements, merge permissions, branch protection policies, triage processes
- Codebase: code comprehensibility, technical debt level, API documentation coverage, module complexity

These mechanisms should be named explicitly in narratives (not lumped as "learning happens", "community matters", or "governance affects").
